# Goal

The goal is to create a Minimal WebAPI using .NET 8.0 and a corresponding Docker image with the help of GitHub Copilot.
Follow the instructions below and try to use GitHub Copilot as much as possible.
Try different things and see what GitHub Copilot can do for you, like generating a Dockerfile or a class, add comments, etc.

> Make sure GitHub Copilot is configure and enabled for the current laguage, just check the status bar on the bottom right corner of VS Code.

## Prompt Engineering Tips
How you formulate your prompts has effects greatly the quality of the responses produced by Copilot. Keep the following core prompt engineering best practices in mind while using Copilot or any LLM based tool.

**Keep the prompts Simple**
* Don't try to do everything in one prompt
* Small, specific questions result in better suggestions
* Break complex tasks into simpler tasks

**Keep the prompts Specific**
* Highlight the targeted code in the IDE
* Use unambiguous questions
* Add enough context to the prompts
* Be aware of the context Copilot adds automatically to context (open tabs)

**Keep the prompts Short**
* As short *as possile*
* Use concise and simple language
* Correct grammar or complete sentences not important

**Give examples for better context**
* Example input data
* Example outputs
* Example implementations

**Keep history relevant**
* Do not confuse Copilot with previous questions
* Opening a new chat session when starting a new topic (by clicking the button)

**Write clean code**
* Good naming conventions
* Modular code
* Clear structure
* Comments when needed

## Exercise Instructions

The `dotnet` folder contains the `MinimalAPI.sln` solution, with 2 projects:

- `MinimalAPI` is a minimal WebAPI project created using `dotnet new webapi -minimal`
- `MinimalAPI.Tests` is a minimal xUnit project created using `dotnet new xunit`

To run the tests, open a terminal in the `dotnet` folder and run:

``` bash
dotnet test
```

To run the app, open a terminal in the `dotnet` folder and run:

**Windows environments**
``` powershell
dotnet run --project .\MinimalAPI\MinimalAPI.csproj
```

**Codespaces, Linux & Unix environments**
``` bash
dotnet run --project ./MinimalAPI/MinimalAPI.csproj
```

### Exercise 1: Introduction

- Inside `MinimalAPI\Program.cs` add a new Hello World endpoint at `/` that returns a `Hello World!` string. You can test the Copilot inline feature by pressing `ctrl + i`. Then write in the text box the desired behaviour. 
- Run `dotnet test`
- If test pass you should see something like this:

``` bash
Microsoft (R) Test Execution Command Line Tool Version 17.6.0 (x64)
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: < 1 ms - MinimalAPI.Tests.dll
```

### Exercise 2: Choosing the LLM model
Copilot supports multiple LLM models. In the chat window, you can select any LLM model enabled by your organization's GitHub Copilot administrator. GitHub revises the models constantly. Currently the default model is GPT 4.1 (6 June 2025), but this could change with short notice. GitHub constantly adds and deprecates models.

1. Study the first section of GitHub's [Choosing the right AI model for your task](https://docs.github.com/en/enterprise-cloud@latest/copilot/using-github-copilot/ai-models/choosing-the-right-ai-model-for-your-task#comparison-of-ai-models-for-github-copilot) document. It is a good idea to bookmark this page and check it periodically.
2. Keep the recommendations in mind and choose the correct model depending on the task.
3. To check which models (and features) your organization has enabled, visit [this page](https://github.com/settings/copilot/features) on GitHub.com.
4. As of 4 June 2025, GitHub has moved to premium request-based billing. Each model has a multiplier that determines how many premium requests they consume. Premium request quotas of the developers depend on the Copilot license type and organization policies. See [GitHub's documentation](https://docs.github.com/en/enterprise-cloud@latest/copilot/managing-copilot/monitoring-usage-and-entitlements/about-premium-requests) for more information.

### Exercise 3: Custom Instructions
Custom instruction files allow you to append coding conventions, patterns, technologies, and other relevant information about your project to every prompt automatically. This enables your team to generate consistent code with Copilot and helps Copilot to understand your project better.

1. Create a file in your project called .github/copilot-instructions.md.
2. As a test, add a single line in the file, e.g., "Use comments to document all code generated by Copilot." Save and close the file.
3. In the chat window, write a prompt asking to generate, e.g., a new function.
4. In the prompt response, notice how the copilot-instructions.md is automatically added to the context (by clicking the "References" expand icon).
5. Make sure that the custom instruction is respected in the generated code.
6. Create more contents for the copilot-instructions.md file. Use standard Markdown notation. It depends on your needs and conventions what content is relevant in the file, but common contents include:
   * Domain vocabulary explained
   * Explanation of the project structure
   * Preferred package managers, unit test frameworks, libraries, etc.
   * Instructions on how to run the development environment
   * Instructions on how to run the unit tests (note: useful when using agent mode)
   * Coding conventions, e.g., indentation, function and variable naming conventions
   * Patterns used in the codebase

### Exercise 4: Building new functionalities
Inside `MinimalAPI\Program.cs` add the following endpoints using the help of Copilot:

- **/DaysBetweenDates**: 

    * calculate days between two dates
    * receive by query string two parameters `date1` and `date2`, and calculate the days between those two dates.

> **_NOTE:_** Use above information inside the Copilot inline feature in the `Program.cs` file. Press enter and wait for Copilot to suggest you the code.

- **/validatephonenumber**: 

    * receive by querystring a parameter called phoneNumber
    * validate phoneNumber with Spanish format, for example `+34666777888`
    * if phoneNumber is valid return true

> **_NOTE:_** Use above information inside a comment in the `Program.cs` file. Press enter and wait for Copilot to suggest you the code.

- **/validatespanishdni**:

    * receive by querystring a parameter called dni
    * calculate DNI letter
    * if DNI is valid return "valid"
    * if DNI is not valid return "invalid"

> **_NOTE:_** Use above information inside a comment in the `Program.cs` file. In this case, you may want to see multiple solutions from Copilot to pick the one that best fits the way to calculate the letter. In order to see the firs 10 suggestions from Copilot press `ctrl + enter`. 

- **/returncolorcode**:

    * receive by querystring a parameter called color
    * read colors.json file and return the rgba field
    * get color var from querystring
    * iterate for each color in colors.json to find the color
    * return the code.hex field

> **_NOTE:_** Lets try Copilot chat now. Paste the above information and make it as detailed as possible in the Copilot chat text box. Copilot will use by default the open file as context in order to generate the suggestion.

- **/tellmeajoke**:

    * Make a call to the joke api and return a random joke

> **_NOTE:_** Here's example where you might need to use you own knowledge and judgement
to validate that Copilot follows best practices. Just because Copilot mimic 
what many developers do, doesn't always mean it's the correct way. You might need 
to be extra specific in your prompt to let Copilot know what's best practices. 
_Hint: Pay attention to HttpClient._
        
- **/moviesbytitle**:

    * Receive by querystring a parameter called director
    * Make a call to the movie api and return a list of movies of that director
    * Return the full list of movies

> **_NOTE:_** This will require to browse to https://www.omdbapi.com/apikey.aspx and request a FREE API Key

- **/parseurl**:

    * Retrieves a parameter from querystring called someurl
    * Parse the url and return the protocol, host, port, path, querystring and hash
    * Return the parsed host

> **_NOTE:_** Copilot can help you learn new frameworks.

- **/listfiles**:

    * Get the current directory
    * Get the list of files in the current directory
    * Return the list of files

> **_NOTE:_** Copilot can also help with these kind of commands locally. The feature is called Copilot in the CLI. You can learn more information about this feature [here](https://docs.github.com/en/copilot/github-copilot-in-the-cli/about-github-copilot-in-the-cli).

- **/GetFullTextFile**:

  * Read `sample.txt`` and return lines that contains the word "Fusce"

  > **_NOTE:_** Becareful with this implementation, since this normally reads the full content of the file before analizing it, so memory usage is high and may fail when files are too big.
  >
  > You can use Copilot Code completion or inline chat. Once done you can also use Copilot Inline Chat to refactor the code to put this logic in a function.

- **/GetLineByLinefromtTextFile**:

  * Read `sample.txt` line by line
  * Create a promise to read the file line by line, and return a list of lines that contains the word "Fusce"
  * Return the list of lines

  > **_NOTE:_** You can use Copilot Code completion or inline chat. Once done you can also use Copilot Inline Chat to refactor the code to put this logic in a function.

- **/calculatememoryconsumption**:

    * Return the memory consumption of the process in GB, rounded to 2 decimals

- **/randomeuropeancountry**:

    * Make an array of european countries and its iso codes
    * Return a random country from the array
    * Return the country and its iso code

### Exercise 5: Chat participants / references / slash commands

Familiarize yourself with chat participants, references and slash commands available in Visual Studio that you don't know yet.

**Chat participants**
Chat participants are domain experts that can answer prompts within a specific domain.

* @VS: make queries about Visual Studio. Try the following prompts:
  * @VS how can I auto format this file?
  * @VS How can I navigate to a specific line in Visual Studio?

* @workspace: make queries about the whole workspace. @workspace intelligently retrieves and references relevant files and symbols from your workspace to answer these queries. Try the following prompts:
   * @workspace list the technologies used in this project
   * @workspace explain the project structure
   * @workspace where should I put the unit tests?

**References**
References enable you to target specific parts of your code base with your prompts.

* #solution: reference the entire .NET solution
* #\<file name>: target a specific file
* #\<class/method/function name>: target a specific class etc of the codebase
  * Create a prompt that targets a class or a file of the exercise project. An example: use @workspace chat participant in conjunction with a reference to a method to locate where in the code base the method is: "@workspace where is the method #CreateHost defined?"


**Slash commands**
Slash commands are shortcuts that enable you to write prompts faster without having to explicitly type everything yourself. Try the following slash commands:

* /fix: tries to detect a bug in the code and propose a fix for it.
  * Inject a bug in one of the previously implemented API endpoints, select the code and simply type "/fix" in the chat window (ask mode). See whether Copilot is able to detect and fix the problem.

* /explain: explains selected code snippet.
  * Select one of the API endpoints and make Copilot explain what it does

* /optimize: optimizes complex or inefficient code.
  * Use Copilot to generate an overly complex API endpoint with e.g. the following prompt:
    "Create an API endpoint that returns a random number. Make the implementation unnecessarily complicated and inefficient for demo purposes."
  * Highlight the generated code block and use /optimize to improve the implementation.

* /doc: generate documentation.
  * Select the API endpoint for random number generation and ask Copilot to document it.

* /help: ask help on how to use Copilot

### Exercise 6: Generating tests

We will create automated tests to check that the functionality of the previous endpoints is correctly implemented. The tests should be together in the `MinimalAPI.Tests\IntegrationTests.cs` file.

You can leverage Copilot to run the tests. There is a `/tests` slash command that you can directly run from Copilot Chat or by selecting the piece of code you want to create tests for and using the Copilot inline feature. 

### Exercise 7: Create a Dockerfile

Now that we have the new functionality added and tests covering it, lets create a Dockerfile for the Minimal API project. 

- Build the image using Copilot and run the app on port 8080

``` powershell
docker build -t dotnetapp .
docker run -d -p 8080:80 --name dotnetapp dotnetapp
```

### Exercise 8: Next Edit Suggestions

Next Edit Suggestions is a feature that allows Copilot to suggest the next edit based on the current context of the code. This can be very useful when you are working on a specific piece of code and want Copilot to suggest the next logical step.

Make sure you have Next Edit Suggestions enabled in your IDE
- Visual Studio Code: File > Preferences > Settings > Search for "copilot nes" and check "Enable Next Edit Suggestions"
- Visual Studio: Tools > Options > GitHub > Copilot and check "Enable Next Edit Suggestions"

To test this feature, you can create a new class called `Points` in the `MinimalAPI` project. The class should have the following properties and methods:

```csharp
namespace MinimalAPI
{
    public class Points
    {
        public int X { get; set; }
        public int Y { get; set; }
        public Points(int x, int y)
        {
            X = x;
            Y = y;
        }
        public override string ToString()
        {
            return $"({X}, {Y})";
        }

        public double DistanceTo(Points other)
        {
            return Math.Sqrt(Math.Pow(other.X - X, 2) + Math.Pow(other.Y - Y, 2));
        }
    }
}
```

You don't have to add endpoint for this exercise to get familiar with the NES.

Next, simply rename Points to Points3D and wait a moment to see how Copilot suggests the next edit. You can also try to add a new property called `Z` and see how Copilot suggests the next edit. Suggestions are incremental, so there is going to be multiple suggestions for the next edit. You can use the `Tab` key to accept the suggestion. Feel free to try different things and see how Copilot suggests the next edit based on the current context of the code in other exercises as well.

### Exercise 9: Copilot Vision

Vision is a feature that allows Copilot to understand the context of the code by analyzing the code in the IDE. This can be very useful when you are working on a specific piece of code and want Copilot to suggest the next logical step. In this exercise, we will use diagram file under resources folder to generate Terraform code for the infrastructure.

Relative path for the diagram file is: `exercisefiles/dotnet/resources/diagram.png`

Open Copilot chat in Ask or Agent mode and drag the diagram file to the chat window. Ask from Copilot what the diagram is about and what it represents. Copilot should be able to understand the context of the diagram and suggest the next logical step. Then ask Copilot to generate Terraform code for the infrastructure represented in the diagram. Copilot should be able to generate the code based on the context of the diagram.

You can also test Vision with screenshot of the code, errors or even a about website layout and request for the change based on the screenshot.

### Exercise 10: Edits Mode
Edits mode allows you to target multiple files with a single prompt. This allows refactoring code over multiple files, which would not be feasible using the ask mode.

Note: Agent Mode is currently (6 June 2025) available in public preview in Visual Studio. If Agent Mode is enabled in the settings, the Edits panel is hidden from the UI. To be able to use the Edits panel, you must first disable Agent Mode if you had previously enabled it.

In this exercise scenario, we assume that the business logic of one of the API endpoints has changed, and the change has to be reflected in both application and test code.
1. Click on the Edits mode button in the chat window.
2. To target multiple files, you must define the working set. Do this by dragging the files from the files explorer to the Copilot chat window. The working set should include Minimal API application code for the endpoints and the test code generated in the previous exercises.
3. Write a prompt that targets both the application code and the test code, changing the application in a way that also requires changes in the test code.
4. Execute the prompt and make sure that the result is correct. Rerun the tests to make sure they still pass.

### Bonus exercise: Agent mode
Copilot Agent mode enables Copilot to interact directly with your codebase and apply changes automatically. Unlike Edits mode, Agent mode does not require you to define a working set of files. Instead, Copilot analyzes the entire project context and can suggest or implement changes across multiple files as needed. This makes Agent mode especially useful for larger refactoring tasks or when you want Copilot to proactively update your codebase based on broader context.

> **Hint:** While Agent mode analyzes your entire project, adding explicit references to files, classes, or functions in your prompt can significantly improve the accuracy of Copilot's suggestions—especially if Agent mode does not provide the desired results out of the box. Use references to guide Copilot to the most relevant parts of your codebase when needed.

> **Hint:** If you are using **Visual Studio Code**, it would benefit if you have this dotnet directory (exercisefiles/dotnet) open in the workspace instead of the whole repository. This way, Copilot can focus on the relevant files and provide more accurate suggestions. If you are using **Visual Studio**, opening the solution file (`MinimalAPI.sln`) is sufficient, as Visual Studio automatically sets the context to the solution.

Make sure you have Agent mode enabled in your IDE
- Visual Studio Code: File > Preferences > Settings > Search for "copilot agent" or navigate to Features > Chat and check "Agent Enabled"
- Visual Studio: Tools > Options > GitHub > Copilot and check "Enable Agent mode in the chat pane"

1. Open the Copilot chat in Agent mode
2. Ask Copilot to create Points3D class that supports coordinates
    - If you already have the file existing from the Next Edit Suggestions exercise, Copilot should recognize it and suggest to update the existing class if even required
3. Ask Copilot to add endpoint for the implemented methods of the Points3D class
4. Ask Copilot to create tests for the Points3D class and the new endpoint
    - It should automatically recognize the existing test project and add the tests there. If not, guide Copilot to the correct test project by using references in your prompt.
