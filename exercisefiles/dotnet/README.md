# Goal

The goal is to create a Minimal WebAPI using .NET 8.0 and a corresponding Docker image with the help of GitHub Copilot.
Follow the instructions below and try to use GitHub Copilot as much as possible.
Try different things and see what GitHub Copilot can do for you, like generating a Dockerfile or a class, add comments, etc.

> Make sure GitHub Copilot is configure and enabled for the current laguage, just check the status bar on the bottom right corner of VS Code.

## Prompt Engineering Tips
How you formulate your prompts has effects greatly the quality of the responses produced by Copilot. Keep the following core prompt engineering best practices in mind while using Copilot or any LLM based tool.

**Keep the prompts Simple**
* Don't try to do everything in one prompt
* Small, specific questions result in better suggestions
* Break complex tasks into simpler tasks

**Keep the prompts Specific**
* Highlight the targeted code in the IDE
* Use unambiguous questions
* Add enough context to the prompts
* Be aware of the context Copilot adds automatically to context (open tabs)

**Keep the prompts Short**
* As short *as possile*
* Use concise and simple language
* Correct grammar or complete sentences not important

**Give examples for better context**
* Example input data
* Example outputs
* Example implementations

**Keep history relevant**
* Do not confuse Copilot with previous questions
* Opening a new chat session when starting a new topic (by clicking the button)

**Write clean code**
* Good naming conventions
* Modular code
* Clear structure
* Comments when needed

## Exercise Instructions

The `dotnet` folder contains the `MinimalAPI.sln` solution, with 2 projects:

- `MinimalAPI` is a minimal WebAPI project created using `dotnet new webapi -minimal`
- `MinimalAPI.Tests` is a minimal xUnit project created using `dotnet new xunit`

To run the tests, open a terminal in the `dotnet` folder and run:

``` bash
dotnet test
```

To run the app, open a terminal in the `dotnet` folder and run:

**Windows environments**
``` powershell
dotnet run --project .\MinimalAPI\MinimalAPI.csproj
```

**Codespaces, Linux & Unix environments**
``` bash
dotnet run --project ./MinimalAPI/MinimalAPI.csproj
```

### Exercise 1: Introduction

- Inside `MinimalAPI\Program.cs` add a new Hello World endpoint at `/` that returns a `Hello World!` string. You can test the Copilot inline feature by pressing `ctrl + i`. Then write in the text box the desired behaviour. 
- Run `dotnet test`
- If test pass you should see something like this:

``` bash
Microsoft (R) Test Execution Command Line Tool Version 17.6.0 (x64)
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: < 1 ms - MinimalAPI.Tests.dll
```

### Exercise 2: Choosing the LLM model
Copilot supports multiple LLM models. In the chat window, you can select any LLM model enabled by your organization's GitHub Copilot administrator. GitHub revises the models constantly. Currently the default model is GPT 4.1 (6 June 2025), but this could change with short notice. GitHub constantly adds and deprecates models.

1. Study the first section of GitHub's [Choosing the right AI model for your task](https://docs.github.com/en/enterprise-cloud@latest/copilot/using-github-copilot/ai-models/choosing-the-right-ai-model-for-your-task#comparison-of-ai-models-for-github-copilot) document. It is a good idea to bookmark this page and check it periodically.
2. Keep the recommendations in mind and choose the correct model depending on the task.
3. To check which models (and features) your organization has enabled, visit [this page](https://github.com/settings/copilot/features) on GitHub.com.
4. As of 4 June 2025, GitHub has moved to premium request-based billing. Each model has a multiplier that determines how many premium requests they consume. Premium request quotas of the developers depend on the Copilot license type and organization policies. See [GitHub's documentation](https://docs.github.com/en/enterprise-cloud@latest/copilot/managing-copilot/monitoring-usage-and-entitlements/about-premium-requests) for more information.

### Exercise 3: Custom Instructions
Custom instruction files allow you to append coding conventions, patterns, technologies, and other relevant information about your project to every prompt automatically. This enables your team to generate consistent code with Copilot and helps Copilot to understand your project better.

1. Create a file in your project called .github/copilot-instructions.md.
2. As a test, add a single line in the file, e.g., "Use comments to document all code generated by Copilot." Save and close the file.
3. In the chat window, write a prompt asking to generate, e.g., a new function.
4. In the prompt response, notice how the copilot-instructions.md is automatically added to the context (by clicking the "References" expand icon).
5. Make sure that the custom instruction is respected in the generated code.
6. Create more contents for the copilot-instructions.md file. Use standard Markdown notation. It depends on your needs and conventions what content is relevant in the file, but common contents include:
   * Domain vocabulary explained
   * Explanation of the project structure
   * Preferred package managers, unit test frameworks, libraries, etc.
   * Instructions on how to run the development environment
   * Instructions on how to run the unit tests (note: useful when using agent mode)
   * Coding conventions, e.g., indentation, function and variable naming conventions
   * Patterns used in the codebase

### Exercise 4: Building new functionalities
Inside `MinimalAPI\Program.cs` add the following endpoints using the help of Copilot:

- **/DaysBetweenDates**: 

    * calculate days between two dates
    * receive by query string two parameters `date1` and `date2`, and calculate the days between those two dates.

> **_NOTE:_** Use above information inside the Copilot inline feature in the `Program.cs` file. Press enter and wait for Copilot to suggest you the code.

- **/validatephonenumber**: 

    * receive by querystring a parameter called phoneNumber
    * validate phoneNumber with Spanish format, for example `+34666777888`
    * if phoneNumber is valid return true

> **_NOTE:_** Use above information inside a comment in the `Program.cs` file. Press enter and wait for Copilot to suggest you the code.

- **/validatespanishdni**:

    * receive by querystring a parameter called dni
    * calculate DNI letter
    * if DNI is valid return "valid"
    * if DNI is not valid return "invalid"

> **_NOTE:_** Use above information inside a comment in the `Program.cs` file. In this case, you may want to see multiple solutions from Copilot to pick the one that best fits the way to calculate the letter. In order to see the firs 10 suggestions from Copilot press `ctrl + enter`. 

- **/returncolorcode**:

    * receive by querystring a parameter called color
    * read colors.json file and return the rgba field
    * get color var from querystring
    * iterate for each color in colors.json to find the color
    * return the code.hex field

> **_NOTE:_** Lets try Copilot chat now. Paste the above information and make it as detailed as possible in the Copilot chat text box. Copilot will use by default the open file as context in order to generate the suggestion.

- **/tellmeajoke**:

    * Make a call to the joke api and return a random joke

> **_NOTE:_** Here's example where you might need to use you own knowledge and judgement
to validate that Copilot follows best practices. Just because Copilot mimic 
what many developers do, doesn't always mean it's the correct way. You might need 
to be extra specific in your prompt to let Copilot know what's best practices. 
_Hint: Pay attention to HttpClient._
        
- **/moviesbytitle**:

    * Receive by querystring a parameter called director
    * Make a call to the movie api and return a list of movies of that director
    * Return the full list of movies

> **_NOTE:_** This will require to browse to https://www.omdbapi.com/apikey.aspx and request a FREE API Key

- **/parseurl**:

    * Retrieves a parameter from querystring called someurl
    * Parse the url and return the protocol, host, port, path, querystring and hash
    * Return the parsed host

> **_NOTE:_** Copilot can help you learn new frameworks.

- **/listfiles**:

    * Get the current directory
    * Get the list of files in the current directory
    * Return the list of files

> **_NOTE:_** Copilot can also help with these kind of commands locally. The feature is called Copilot in the CLI. You can learn more information about this feature [here](https://docs.github.com/en/copilot/github-copilot-in-the-cli/about-github-copilot-in-the-cli).

- **/GetFullTextFile**:

  * Read `sample.txt`` and return lines that contains the word "Fusce"

  > **_NOTE:_** Becareful with this implementation, since this normally reads the full content of the file before analizing it, so memory usage is high and may fail when files are too big.
  >
  > You can use Copilot Code completion or inline chat. Once done you can also use Copilot Inline Chat to refactor the code to put this logic in a function.

- **/GetLineByLinefromtTextFile**:

  * Read `sample.txt` line by line
  * Create a promise to read the file line by line, and return a list of lines that contains the word "Fusce"
  * Return the list of lines

  > **_NOTE:_** You can use Copilot Code completion or inline chat. Once done you can also use Copilot Inline Chat to refactor the code to put this logic in a function.

- **/calculatememoryconsumption**:

    * Return the memory consumption of the process in GB, rounded to 2 decimals

- **/randomeuropeancountry**:

    * Make an array of european countries and its iso codes
    * Return a random country from the array
    * Return the country and its iso code

### Exercise 5: Document the code

Documenting code is always a boring and painful task. However, we can use Copilot to document it for us. In the chat, ask Copilot to document the Program.cs file. 

### Exercise 6: Building tests

We will create automated tests to check that the functionality of the previous endpoints is correctly implemented. The tests should be together in the `MinimalAPI.Tests\IntegrationTests.cs` file.

You can leverage Copilot to run the tests. There is a `/tests` command that you can directly run from Copilot Chat or by selecting the piece of code you want to create tests for and using the Copilot inline feature. 

### Exercise 7: Create a Dockerfile

Now that we have the new functionality added and tests covering it, lets create a Dockerfile for the Minimal API project. 

- Build the image using Copilot and run the app on port 8080

``` powershell
docker build -t dotnetapp .
docker run -d -p 8080:80 --name dotnetapp dotnetapp
```

### Exercise 8: Next Edit Suggestions

Next Edit Suggestions is a feature that allows Copilot to suggest the next edit based on the current context of the code. This can be very useful when you are working on a specific piece of code and want Copilot to suggest the next logical step.

Make sure you have Next Edit Suggestions enabled in your IDE
- Visual Studio Code: File > Preferences > Settings > Search for "copilot nes" and check "Enable Next Edit Suggestions"
- Visual Studio: Tools > Options > GitHub > Copilot and check "Enable Next Edit Suggestions"

To test this feature, you can create a new class called `Points` in the `MinimalAPI` project. The class should have the following properties and methods:

```csharp
namespace MinimalAPI
{
    public class Points
    {
        public int X { get; set; }
        public int Y { get; set; }
        public Points(int x, int y)
        {
            X = x;
            Y = y;
        }
        public override string ToString()
        {
            return $"({X}, {Y})";
        }

        public double DistanceTo(Points other)
        {
            return Math.Sqrt(Math.Pow(other.X - X, 2) + Math.Pow(other.Y - Y, 2));
        }
    }
}
```

You don't have to add endpoint for this exercise to get familiar with the NES.

Next, simply rename Points to Points3D and wait a moment to see how Copilot suggests the next edit. You can also try to add a new property called `Z` and see how Copilot suggests the next edit. Suggestions are incremental, so there is going to be multiple suggestions for the next edit. You can use the `Tab` key to accept the suggestion. Feel free to try different things and see how Copilot suggests the next edit based on the current context of the code in other exercises as well.

### Exercise 9: Copilot Vision

Vision is a feature that allows Copilot to understand the context of the code by analyzing the code in the IDE. This can be very useful when you are working on a specific piece of code and want Copilot to suggest the next logical step. In this exercise, we will use diagram file under resources folder to generate Terraform code for the infrastructure.

Relative path for the diagram file is: `exercisefiles/dotnet/resources/diagram.png`

Open Copilot chat in Ask or Agent mode and drag the diagram file to the chat window. Ask from Copilot what the diagram is about and what it represents. Copilot should be able to understand the context of the diagram and suggest the next logical step. Then ask Copilot to generate Terraform code for the infrastructure represented in the diagram. Copilot should be able to generate the code based on the context of the diagram.

You can also test Vision with screenshot of the code, errors or even a about website layout and request for the change based on the screenshot.

### Exercise 10: Chat participants / references / slash commands drills
TODO: Hannu
- Participants: @VS, @Workspace
- Reference: #solution (make a prompt asking something about the solution), #<file>, #<class/method/function>
- Slash commands: /explain, /fix (inject a bug and see if Copilot can fix it), /optimize (provide a function that can be optimized), /help, /doc

### Exercise 11: Edits Mode
Edits mode allows you to target multiple files with a single prompt. This allows refactoring code over multiple files, which would not be feasible using the ask mode.

Note: Agent Mode is currently (6 June 2025) available in public preview in Visual Studio. If Agent Mode is enabled in the settings, the Edits panel is hidden from the UI. To be able to use the Edits panel, you must first disable Agent Mode if you had previously enabled it.

In this exercise scenario, we assume that the business logic of one of the API endpoints has changed, and the change has to be reflected in both application and test code.
1. Click on the Edits mode button in the chat window.
2. To target multiple files, you must define the working set. Do this by dragging the files from the files explorer to the Copilot chat window. The working set should include Minimal API application code for the endpoints and the test code generated in the previous exercises.
3. Write a prompt that targets both the application code and the test code, changing the application in a way that also requires changes in the test code.
4. Execute the prompt and make sure that the result is correct. Rerun the tests to make sure they still pass.

### Bonus exercise: Agent mode
TODO: Hannu

Make sure you have Agent mode enabled in your IDE
- Visual Studio Code: 
- Visual Studio: 

## Summary

With the previous exercises you have gone through some common activities that developers usually run:
- Create new features in the code
- Work with external APIs
- Create documentation
- Create tests

However, there are many other things that Copilot can help you with. Feel free to explore other slash command in the Copilot chat like:
- `/fix`: to fix the problems in your code
- `/explain`: for Copilot to explain you what the code does
